// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package database

import (
	"context"
	"github.com/google/uuid"
	v1beta2 "github.com/kubeflow/spark-operator/v2/api/v1beta2"
	"sync"
	"time"
)

// Ensure, that SparkApplicationDatabaseMock does implement SparkApplicationDatabase.
// If this is not the case, regenerate this file with moq.
var _ SparkApplicationDatabase = &SparkApplicationDatabaseMock{}

// SparkApplicationDatabaseMock is a mock implementation of SparkApplicationDatabase.
//
//	func TestSomethingThatUsesSparkApplicationDatabase(t *testing.T) {
//
//		// make and configure a mocked SparkApplicationDatabase
//		mockedSparkApplicationDatabase := &SparkApplicationDatabaseMock{
//			GetByIdFunc: func(ctx context.Context, gatewayIdUid uuid.UUID) (*SparkApplication, error) {
//				panic("mock out the GetById method")
//			},
//			InsertSparkApplicationFunc: func(ctx context.Context, gatewayIdUid uuid.UUID, creationTime time.Time, userSubmittedSparkApp *v1beta2.SparkApplication, clusterName string) error {
//				panic("mock out the InsertSparkApplication method")
//			},
//			UpdateSparkApplicationFunc: func(ctx context.Context, gatewayIdUid uuid.UUID, updateSparkApp v1beta2.SparkApplication) error {
//				panic("mock out the UpdateSparkApplication method")
//			},
//		}
//
//		// use mockedSparkApplicationDatabase in code that requires SparkApplicationDatabase
//		// and then make assertions.
//
//	}
type SparkApplicationDatabaseMock struct {
	// GetByIdFunc mocks the GetById method.
	GetByIdFunc func(ctx context.Context, gatewayIdUid uuid.UUID) (*SparkApplication, error)

	// InsertSparkApplicationFunc mocks the InsertSparkApplication method.
	InsertSparkApplicationFunc func(ctx context.Context, gatewayIdUid uuid.UUID, creationTime time.Time, userSubmittedSparkApp *v1beta2.SparkApplication, clusterName string) error

	// UpdateSparkApplicationFunc mocks the UpdateSparkApplication method.
	UpdateSparkApplicationFunc func(ctx context.Context, gatewayIdUid uuid.UUID, updateSparkApp v1beta2.SparkApplication) error

	// calls tracks calls to the methods.
	calls struct {
		// GetById holds details about calls to the GetById method.
		GetById []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GatewayIdUid is the gatewayIdUid argument value.
			GatewayIdUid uuid.UUID
		}
		// InsertSparkApplication holds details about calls to the InsertSparkApplication method.
		InsertSparkApplication []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GatewayIdUid is the gatewayIdUid argument value.
			GatewayIdUid uuid.UUID
			// CreationTime is the creationTime argument value.
			CreationTime time.Time
			// UserSubmittedSparkApp is the userSubmittedSparkApp argument value.
			UserSubmittedSparkApp *v1beta2.SparkApplication
			// ClusterName is the clusterName argument value.
			ClusterName string
		}
		// UpdateSparkApplication holds details about calls to the UpdateSparkApplication method.
		UpdateSparkApplication []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GatewayIdUid is the gatewayIdUid argument value.
			GatewayIdUid uuid.UUID
			// UpdateSparkApp is the updateSparkApp argument value.
			UpdateSparkApp v1beta2.SparkApplication
		}
	}
	lockGetById                sync.RWMutex
	lockInsertSparkApplication sync.RWMutex
	lockUpdateSparkApplication sync.RWMutex
}

// GetById calls GetByIdFunc.
func (mock *SparkApplicationDatabaseMock) GetById(ctx context.Context, gatewayIdUid uuid.UUID) (*SparkApplication, error) {
	if mock.GetByIdFunc == nil {
		panic("SparkApplicationDatabaseMock.GetByIdFunc: method is nil but SparkApplicationDatabase.GetById was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		GatewayIdUid uuid.UUID
	}{
		Ctx:          ctx,
		GatewayIdUid: gatewayIdUid,
	}
	mock.lockGetById.Lock()
	mock.calls.GetById = append(mock.calls.GetById, callInfo)
	mock.lockGetById.Unlock()
	return mock.GetByIdFunc(ctx, gatewayIdUid)
}

// GetByIdCalls gets all the calls that were made to GetById.
// Check the length with:
//
//	len(mockedSparkApplicationDatabase.GetByIdCalls())
func (mock *SparkApplicationDatabaseMock) GetByIdCalls() []struct {
	Ctx          context.Context
	GatewayIdUid uuid.UUID
} {
	var calls []struct {
		Ctx          context.Context
		GatewayIdUid uuid.UUID
	}
	mock.lockGetById.RLock()
	calls = mock.calls.GetById
	mock.lockGetById.RUnlock()
	return calls
}

// InsertSparkApplication calls InsertSparkApplicationFunc.
func (mock *SparkApplicationDatabaseMock) InsertSparkApplication(ctx context.Context, gatewayIdUid uuid.UUID, creationTime time.Time, userSubmittedSparkApp *v1beta2.SparkApplication, clusterName string) error {
	if mock.InsertSparkApplicationFunc == nil {
		panic("SparkApplicationDatabaseMock.InsertSparkApplicationFunc: method is nil but SparkApplicationDatabase.InsertSparkApplication was just called")
	}
	callInfo := struct {
		Ctx                   context.Context
		GatewayIdUid          uuid.UUID
		CreationTime          time.Time
		UserSubmittedSparkApp *v1beta2.SparkApplication
		ClusterName           string
	}{
		Ctx:                   ctx,
		GatewayIdUid:          gatewayIdUid,
		CreationTime:          creationTime,
		UserSubmittedSparkApp: userSubmittedSparkApp,
		ClusterName:           clusterName,
	}
	mock.lockInsertSparkApplication.Lock()
	mock.calls.InsertSparkApplication = append(mock.calls.InsertSparkApplication, callInfo)
	mock.lockInsertSparkApplication.Unlock()
	return mock.InsertSparkApplicationFunc(ctx, gatewayIdUid, creationTime, userSubmittedSparkApp, clusterName)
}

// InsertSparkApplicationCalls gets all the calls that were made to InsertSparkApplication.
// Check the length with:
//
//	len(mockedSparkApplicationDatabase.InsertSparkApplicationCalls())
func (mock *SparkApplicationDatabaseMock) InsertSparkApplicationCalls() []struct {
	Ctx                   context.Context
	GatewayIdUid          uuid.UUID
	CreationTime          time.Time
	UserSubmittedSparkApp *v1beta2.SparkApplication
	ClusterName           string
} {
	var calls []struct {
		Ctx                   context.Context
		GatewayIdUid          uuid.UUID
		CreationTime          time.Time
		UserSubmittedSparkApp *v1beta2.SparkApplication
		ClusterName           string
	}
	mock.lockInsertSparkApplication.RLock()
	calls = mock.calls.InsertSparkApplication
	mock.lockInsertSparkApplication.RUnlock()
	return calls
}

// UpdateSparkApplication calls UpdateSparkApplicationFunc.
func (mock *SparkApplicationDatabaseMock) UpdateSparkApplication(ctx context.Context, gatewayIdUid uuid.UUID, updateSparkApp v1beta2.SparkApplication) error {
	if mock.UpdateSparkApplicationFunc == nil {
		panic("SparkApplicationDatabaseMock.UpdateSparkApplicationFunc: method is nil but SparkApplicationDatabase.UpdateSparkApplication was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		GatewayIdUid   uuid.UUID
		UpdateSparkApp v1beta2.SparkApplication
	}{
		Ctx:            ctx,
		GatewayIdUid:   gatewayIdUid,
		UpdateSparkApp: updateSparkApp,
	}
	mock.lockUpdateSparkApplication.Lock()
	mock.calls.UpdateSparkApplication = append(mock.calls.UpdateSparkApplication, callInfo)
	mock.lockUpdateSparkApplication.Unlock()
	return mock.UpdateSparkApplicationFunc(ctx, gatewayIdUid, updateSparkApp)
}

// UpdateSparkApplicationCalls gets all the calls that were made to UpdateSparkApplication.
// Check the length with:
//
//	len(mockedSparkApplicationDatabase.UpdateSparkApplicationCalls())
func (mock *SparkApplicationDatabaseMock) UpdateSparkApplicationCalls() []struct {
	Ctx            context.Context
	GatewayIdUid   uuid.UUID
	UpdateSparkApp v1beta2.SparkApplication
} {
	var calls []struct {
		Ctx            context.Context
		GatewayIdUid   uuid.UUID
		UpdateSparkApp v1beta2.SparkApplication
	}
	mock.lockUpdateSparkApplication.RLock()
	calls = mock.calls.UpdateSparkApplication
	mock.lockUpdateSparkApplication.RUnlock()
	return calls
}
