// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package database

import (
	"context"
	"sync"
)

// Ensure, that LivyApplicationDatabaseMock does implement LivyApplicationDatabase.
// If this is not the case, regenerate this file with moq.
var _ LivyApplicationDatabase = &LivyApplicationDatabaseMock{}

// LivyApplicationDatabaseMock is a mock implementation of LivyApplicationDatabase.
//
//	func TestSomethingThatUsesLivyApplicationDatabase(t *testing.T) {
//
//		// make and configure a mocked LivyApplicationDatabase
//		mockedLivyApplicationDatabase := &LivyApplicationDatabaseMock{
//			GetByBatchIdFunc: func(ctx context.Context, batchId int) (LivyApplication, error) {
//				panic("mock out the GetByBatchId method")
//			},
//			InsertLivyApplicationFunc: func(ctx context.Context, gatewayId string) (LivyApplication, error) {
//				panic("mock out the InsertLivyApplication method")
//			},
//			ListFromFunc: func(ctx context.Context, fromId int, size int) ([]LivyApplication, error) {
//				panic("mock out the ListFrom method")
//			},
//		}
//
//		// use mockedLivyApplicationDatabase in code that requires LivyApplicationDatabase
//		// and then make assertions.
//
//	}
type LivyApplicationDatabaseMock struct {
	// GetByBatchIdFunc mocks the GetByBatchId method.
	GetByBatchIdFunc func(ctx context.Context, batchId int) (LivyApplication, error)

	// InsertLivyApplicationFunc mocks the InsertLivyApplication method.
	InsertLivyApplicationFunc func(ctx context.Context, gatewayId string) (LivyApplication, error)

	// ListFromFunc mocks the ListFrom method.
	ListFromFunc func(ctx context.Context, fromId int, size int) ([]LivyApplication, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetByBatchId holds details about calls to the GetByBatchId method.
		GetByBatchId []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BatchId is the batchId argument value.
			BatchId int
		}
		// InsertLivyApplication holds details about calls to the InsertLivyApplication method.
		InsertLivyApplication []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GatewayId is the gatewayId argument value.
			GatewayId string
		}
		// ListFrom holds details about calls to the ListFrom method.
		ListFrom []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// FromId is the fromId argument value.
			FromId int
			// Size is the size argument value.
			Size int
		}
	}
	lockGetByBatchId          sync.RWMutex
	lockInsertLivyApplication sync.RWMutex
	lockListFrom              sync.RWMutex
}

// GetByBatchId calls GetByBatchIdFunc.
func (mock *LivyApplicationDatabaseMock) GetByBatchId(ctx context.Context, batchId int) (LivyApplication, error) {
	if mock.GetByBatchIdFunc == nil {
		panic("LivyApplicationDatabaseMock.GetByBatchIdFunc: method is nil but LivyApplicationDatabase.GetByBatchId was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		BatchId int
	}{
		Ctx:     ctx,
		BatchId: batchId,
	}
	mock.lockGetByBatchId.Lock()
	mock.calls.GetByBatchId = append(mock.calls.GetByBatchId, callInfo)
	mock.lockGetByBatchId.Unlock()
	return mock.GetByBatchIdFunc(ctx, batchId)
}

// GetByBatchIdCalls gets all the calls that were made to GetByBatchId.
// Check the length with:
//
//	len(mockedLivyApplicationDatabase.GetByBatchIdCalls())
func (mock *LivyApplicationDatabaseMock) GetByBatchIdCalls() []struct {
	Ctx     context.Context
	BatchId int
} {
	var calls []struct {
		Ctx     context.Context
		BatchId int
	}
	mock.lockGetByBatchId.RLock()
	calls = mock.calls.GetByBatchId
	mock.lockGetByBatchId.RUnlock()
	return calls
}

// InsertLivyApplication calls InsertLivyApplicationFunc.
func (mock *LivyApplicationDatabaseMock) InsertLivyApplication(ctx context.Context, gatewayId string) (LivyApplication, error) {
	if mock.InsertLivyApplicationFunc == nil {
		panic("LivyApplicationDatabaseMock.InsertLivyApplicationFunc: method is nil but LivyApplicationDatabase.InsertLivyApplication was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		GatewayId string
	}{
		Ctx:       ctx,
		GatewayId: gatewayId,
	}
	mock.lockInsertLivyApplication.Lock()
	mock.calls.InsertLivyApplication = append(mock.calls.InsertLivyApplication, callInfo)
	mock.lockInsertLivyApplication.Unlock()
	return mock.InsertLivyApplicationFunc(ctx, gatewayId)
}

// InsertLivyApplicationCalls gets all the calls that were made to InsertLivyApplication.
// Check the length with:
//
//	len(mockedLivyApplicationDatabase.InsertLivyApplicationCalls())
func (mock *LivyApplicationDatabaseMock) InsertLivyApplicationCalls() []struct {
	Ctx       context.Context
	GatewayId string
} {
	var calls []struct {
		Ctx       context.Context
		GatewayId string
	}
	mock.lockInsertLivyApplication.RLock()
	calls = mock.calls.InsertLivyApplication
	mock.lockInsertLivyApplication.RUnlock()
	return calls
}

// ListFrom calls ListFromFunc.
func (mock *LivyApplicationDatabaseMock) ListFrom(ctx context.Context, fromId int, size int) ([]LivyApplication, error) {
	if mock.ListFromFunc == nil {
		panic("LivyApplicationDatabaseMock.ListFromFunc: method is nil but LivyApplicationDatabase.ListFrom was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		FromId int
		Size   int
	}{
		Ctx:    ctx,
		FromId: fromId,
		Size:   size,
	}
	mock.lockListFrom.Lock()
	mock.calls.ListFrom = append(mock.calls.ListFrom, callInfo)
	mock.lockListFrom.Unlock()
	return mock.ListFromFunc(ctx, fromId, size)
}

// ListFromCalls gets all the calls that were made to ListFrom.
// Check the length with:
//
//	len(mockedLivyApplicationDatabase.ListFromCalls())
func (mock *LivyApplicationDatabaseMock) ListFromCalls() []struct {
	Ctx    context.Context
	FromId int
	Size   int
} {
	var calls []struct {
		Ctx    context.Context
		FromId int
		Size   int
	}
	mock.lockListFrom.RLock()
	calls = mock.calls.ListFrom
	mock.lockListFrom.RUnlock()
	return calls
}
